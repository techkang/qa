"""
evaluation.py
~~~~~~~~~~~~~

Evaluates the performance of the `mini_qa.py` question-answering
system.
"""

# Library imports
from __future__ import division
import qa

# Standard library
import json

GOOGLE_PAUSE = 10


class QAPair():
    """
    Stores a question and a list of acceptable answers.
    """

    def __init__(self, question, answers):
        self.question = question
        self.answers = answers


def evaluate():
    """
    Evaluate the question-answering system based on `source`.  Allowed
    values for `source` are explain in the doc string for mini_qa.qa.
    """
    qa_pairs = load_qa_pairs()
    all_answers = get_answers([qa.question for qa in qa_pairs])
    if not all_answers:
        return None
    qa_pairs = qa_pairs[:len(all_answers)]
    num_questions = len(qa_pairs)
    print("Generating candidate answers for %s questions" % num_questions)
    total_score = 0
    for j, (qa_pair, answers) in enumerate(zip(qa_pairs, all_answers)):
        index, score = check_results(
            answers, qa_pair.answers)
        print("\n{} Q: ".format(j) + qa_pair.question)
        for j, answer in enumerate(answers):
            print("%s. %s" % (j + 1, answer))
        print('Correct answer is at {}, score is {}.'.format(index, score))
        total_score += score
    total_score /= len(qa_pairs)
    print('Total score for all answer is {}.'.format(total_score))


def load_qa_pairs():
    """
    Return a list of QAPair instances, loaded from the file
    qa_pairs.json.
    """
    with open("qa_pairs.json", encoding='utf-8') as f:
        qa_pairs = json.load(f)
    return [QAPair(qa_pair["question"], qa_pair["answers"])
            for qa_pair in qa_pairs]


def get_answers(question):
    """
    Return a list of the top 20 answers generated by `mini_qa.qa` to
    `question`.
    """
    if type(question) == list:
        answers = qa.google_qa_quick(question, pause=10)
        result = []
        for i, every_answer in enumerate(answers):
            result.append([answer for (answer, score) in every_answer[:10]])
        return result
    return [answer for (answer, score) in qa.google_qa(question, pause=GOOGLE_PAUSE)[:10]]


def check_results(candidate_answers, acceptable_answers):
    """
    Return a list containing the ranking of all elements of the list
    `candidate_answers` which are also in the list of
    `acceptable_answers`.
    """
    total = 0
    for i, answer in enumerate(candidate_answers):
        for acceptable_answer in acceptable_answers:
            if answer == acceptable_answer:
                return i + 1, total + 1 / (i + 1)
            elif answer in acceptable_answer:
                total += 1 / len(candidate_answers)
    return 0, total


if __name__ == "__main__":
    evaluate()
